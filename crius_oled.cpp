
#include "i2c.h"
#include "crius_oled.h"
//#include "font.c"

#include "Arduino.h"

//extern unsigned char myFont[][8];
extern unsigned char SmallFont[];
//unsigned char buffer[64][16];
//unsigned char buffer[64*16];
unsigned char buffer[128*8] = 
{ 
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,
  0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
  0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,
  0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,
  0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,
  0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,
  0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,
  0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0xC2,0x87,0x00,0x00,0x00,0x00,0x00,0x40,0xF2,0x9F,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void displayBuffer()
{
  //sendcommand(0xa6);  //Set Normal Display

  //sendcommand(0x20);            //Set Memory Addressing Mode
  //sendcommand(0x01);            //Set Memory Addressing Mode ab Horizontal addressing mode


  //==========================================================//
  //setXY(0,0);
  
  for(int col = 0; col < 128; col++)     // show 128* 64 picture
  {
    for( int row = 0; row < 8; row++ )
    {
      int idx = ( col * 8 ) + row;
      SendChar(buffer[idx]);
    }
  }
}

void drawPixel( int x, int y, bool draw )
{
  int bitIdx = y + ( x * 64 );
  int pageIdx = bitIdx / 8;
  uint8_t pixelIdx = bitIdx % 8;
  
  if( draw )
    buffer[ pageIdx ] |= 1 << pixelIdx;
  else
    buffer[ pageIdx ] &= ~( 1 << pixelIdx );
}

void drawChar( int x, int y, unsigned char character )
{
  uint8_t startChar = SmallFont[2];
  uint8_t charWidth = SmallFont[5];
  uint8_t charHeight = SmallFont[4];
  int charIdx = ( ( character - startChar ) * charWidth ) + 6;
  
  for( int bytes = 0; bytes < charWidth; bytes++ )
  {
    for( int bits = 0; bits < charHeight; bits++ )
    {
      bool bitValue = SmallFont[ charIdx + bytes ] & ( 1 << bits );
      
      drawPixel( x + bytes, y + bits, bitValue );
    }
  }
}

void drawString( int x, int y, unsigned char * string )
{
  uint8_t charWidth = SmallFont[5];
  uint8_t charHeight = SmallFont[4];
  int runningX = x;
  
  while(*string)
  {
    if( *string == '\n' )
    {
      y += charHeight;
      runningX = x;
    }
    else
    {
      drawChar( runningX, y, *string );
    
      runningX += charWidth;
    }
    
    *string++;
  }
}

void swap(int16_t &r, int16_t &s)
{
    int16_t pSwap = r;
    r = s;
    s = pSwap;
    return;
}

void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      drawPixel(y0, x0, true);
    } else {
      drawPixel(x0, y0, true);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

void sendcommand(unsigned char com)
{
  i2c_OLED_send_cmd(com);  
  /*
  Wire.beginTransmission(OLED_address);     //begin transmitting
   Wire.write(0x80);                          //command mode
   Wire.write(com);
   Wire.endTransmission();                    // stop transmitting
   */
}

//==========================================================//
void clear_display(void)
{
  unsigned char i,k;
  /*for(k=0;k<8;k++)
  {	
    setXY(k,0);    
    {
      for(i=0;i<128;i++)     //clear all COL
      {
        SendChar(0);         //clear all COL
        //delay(10);
      }
    }
  }
  */
  for(int col = 0; col < 128; col++)     // show 128* 64 picture
  {
    for( int row = 0; row < 8; row++ )
    {
      SendChar(0);
    }
  }
}

//==========================================================//
void SendChar(unsigned char data)
{
  i2c_OLED_send_byte(data);
  /*
  Wire.beginTransmission(OLED_address); // begin transmitting
   Wire.write(0x40);//data mode
   Wire.write(data);
   Wire.endTransmission();    // stop transmitting
   */
}

//==========================================================//
void setXY(unsigned char row,unsigned char col)
{
  sendcommand(0xb0+row);                //set page address
  sendcommand(0x00+(8*col&0x0f));       //set low col address
  sendcommand(0x10+((8*col>>4)&0x0f));  //set high col address
}


//==========================================================//
/*void sendStr(unsigned char *string)
{
  unsigned char i=0;
  //setXY(0,0);    
  while(*string)
  {
    for(i=0;i<CHAR_WIDTH;i++)
    {
      SendChar(myFont[*string-0x20][i]);

      // SendChar(*string);
      //delay(10);
    }
    *string++;
  }
}*/

//==========================================================//
void init_OLED(void)
{
/*  i2c_OLED_init();

}

void  i2c_OLED_init(void)
{*/
  delay(50);
  i2c_OLED_send_cmd(0xae);    //display off
  i2c_OLED_send_cmd(0x2e);    //deactivate scrolling
  i2c_OLED_send_cmd(0xa4);          //SET All pixels OFF
  //  i2c_OLED_send_cmd(0xa5);            //SET ALL pixels ON
  delay(50);
  
  //  i2c_OLED_send_cmd(0xa0);      //colum address 0 mapped to SEG0 (POR)*** wires at bottom
  i2c_OLED_send_cmd(0xa1);    //colum address 127 mapped to SEG0 (POR) ** wires at top of board
  //  i2c_OLED_send_cmd(0xC0);            // Scan from Right to Left (POR)         *** wires at bottom
  i2c_OLED_send_cmd(0xC8);          // Scan from Left to Right               ** wires at top
  
  i2c_OLED_send_cmd(0xa6);            // Set WHITE chars on BLACK backround
  
  i2c_OLED_send_cmd(0x20);            //Set Memory Addressing Mode
  i2c_OLED_send_cmd(0x01);            //Set Memory Addressing Mode to Page addressing mode(RESET)
  

  //  i2c_OLED_send_cmd(0xa7);            // Set BLACK chars on WHITE backround
  i2c_OLED_send_cmd(0x81);            // 81 Setup CONTRAST CONTROL, following byte is the contrast Value
  i2c_OLED_send_cmd(0xCC);            // af contrast value between 1 ( == dull) to 255 ( == bright)
  delay(20);

  i2c_OLED_send_cmd(0xaf);          //display on
  delay(20);
}
