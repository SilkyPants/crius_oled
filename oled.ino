//==========================================================//
//-------------------------WWW.WIDE.HK----------------------//
//-----i2c OLED example-------------------------------------//
//-----Function : show 128x64 Graphic , Word and animation--//
//-----SCL = A5  ,  SDA = A4 , VCC = 3.3V-5V , GND----------//
//==========================================================//

#include "Config.h"

#include <avr/io.h>

//---------------FONT + GRAPHIC-----------------------------//
//==========================================================//

unsigned char fill_string1[]="PUMP";
unsigned char fill_string2[]="(";
unsigned char fill_string3[]="$$$$$$$";
unsigned char fill_string4[]="\"\"\"\"\"\"\"";
//extern unsigned char myFont[][8];
extern unsigned char SmallFont[];
//unsigned char buffer[64][16];
//unsigned char buffer[64*16];
unsigned char buffer[128*8]= { 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x80,0x00,0x00,0x00,0x00,0x00,0x40,0xC2,0x87,0x00,0x00,0x00,0x00,0x00,0x40,0xF2,0x9F,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0xEA,0xAF,0x00,0x00,0x00,0x00,0x00,0x40,0x0A,0xA0,0x00,0x00,0x00,0x00,0x00,0x40,0xFA,0xBF,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
bool firstRun = true;

//==========================================================//
/*void print_a_char(unsigned char ascii=0)
 {
 unsigned char i=0;
 for(i=0;i<8;i++)
 {
 SendChar(myFont[ascii-0x20][i]);
 }
 }*/

void drawPixel( int x, int y, bool draw )
{
  int bitIdx = y + ( x * 64 );
  int pageIdx = bitIdx / 8;
  char pixelIdx = bitIdx % 8;
  
  if( draw )
    buffer[ pageIdx ] |= 1 << pixelIdx;
  else
    buffer[ pageIdx ] &= ~( 1 << pixelIdx );
}

void drawChar( int x, int y, unsigned char character )
{
  byte startChar = SmallFont[2];
  byte charWidth = SmallFont[5];
  int charIdx = ( ( character - startChar ) * charWidth ) + 6;
  
  for( int bytes = 0; bytes < charWidth; bytes++ )
  {
    for( int bits = 0; bits < 8; bits++ )
    {
      bool bitValue = SmallFont[ charIdx + bytes ] & ( 1 << bits );
      
      drawPixel( x + bytes, y + bits, bitValue );
    }
  }
}

void drawString( int x, int y, unsigned char * string )
{
  byte charWidth = SmallFont[5];
  byte charHeight = SmallFont[4];
  int runningX = x;
  
  while(*string)
  {
    if( *string == '\n' )
    {
      y += charHeight;
      runningX = x;
    }
    else
    {
      drawChar( runningX, y, *string );
    
      runningX += charWidth;
    }
    
    *string++;
  }
}

void swap(int16_t &r, int16_t &s)
{
    int16_t pSwap = r;
    r = s;
    s = pSwap;
    return;
}

void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1) 
{
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
      drawPixel(y0, x0, true);
    } else {
      drawPixel(x0, y0, true);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

//==========================================================//
void setup()
{

  //  Wire.begin();
  i2c_init();

  pinMode( 2, OUTPUT );
  delay( 1000 );
  digitalWrite( 2, HIGH );
  init_OLED();
  delay(10);
  clear_display();
  delay(50);

  /*for(int row=0; row < 64; row++)     // show 128* 64 picture
   {
   for( int col = 0; col < 16; col++ )
   {
   if( col % 2 == 0)
   buffer[row][col] = 0x00;
   else
   buffer[row][col] = 0xff;
   }
   }*/

  /*int i = 8;
   for( int col = 0; col < 64*16; col++ )
   {
   if( i-- > 0)
   buffer[col] = 0xff;
   else
   buffer[col] = 0x00;
   }*/

  /*for(int x = 0; x < 128; x++)     // show 128* 64 picture
  {
    for( int y = 0; y < 64; y++ )
    {        
        drawPixel( 1, y, 1);//col % 2 == 0 );
    }
  }*/
  
  drawString( 52, 5, fill_string1 );
  drawString( 6, 5, fill_string2 );
  
  /*
  drawChar( 64, 32, 'W' );
  drawChar( 70, 32, 'a' );
  drawChar( 76, 32, 'd' );
  drawChar( 82, 32, 'e' );
  drawChar( 88, 32, ' ' );
  drawChar( 94, 32, ' ' );
  drawChar( 100, 32, ' ' );
  */
}

//==========================================================//
void loop()
{  
/*  clear_display();
  delay(50);

  sendcommand(0x20);            //Set Memory Addressing Mode
  sendcommand(0x02);            //Set Memory Addressing Mode ab Page addressing mode(RESET)  

  sendcommand(0xa6);            //Set Normal Display (default)
  //sendcommand(0xae);		//display off
  //====================SHOW FONTS ARRAY[1-4]=======================//
  setXY(2,3);
  sendStr(fill_string1);
  setXY(3,3);
  sendStr(fill_string2);
  setXY(4,3);
  sendStr(fill_string3);
  setXY(5,3);
  sendStr(fill_string4);
  //sendcommand(0xaf);		//display off

  delay(2000);

  sendcommand(0xa7);  //Set Inverse Display  
  delay(2000); 
*/
  sendcommand(0xa6);  //Set Normal Display

  //sendcommand(0xae);		//display off
  sendcommand(0x20);            //Set Memory Addressing Mode
  sendcommand(0x01);            //Set Memory Addressing Mode ab Horizontal addressing mode


  //==========================================================//
  setXY(0,0);
  /*for(int i=0;i<16;i++)     // show 128* 64 picture
   {
   for( int col = 0; col < 64; col++ )
   {
   SendChar(buffer[i][col]);
   }
   }*/


  /*for( int col = 0; col < 64*16; col++ )
  {
    SendChar(buffer[col]);
  }*/

  for(int col = 0; col < 128; col++)     // show 128* 64 picture
  {
    for( int row = 0; row < 8; row++ )
    {
      int idx = ( col * 8 ) + row;
      SendChar(buffer[idx]);
    }
  }

  //==========================================================//


  //sendcommand(0xaf);
  delay(2000);
  /*  sendcommand(0xa7);    //Set Inverse Display
   delay(2000);  
   
   
   sendcommand(0x23);
   sendcommand(0x30);
   delay(4000);
   sendcommand(0x23);
   sendcommand(0x00);
   delay(2000);  
   sendcommand(0x23);
   sendcommand(0x20);
   delay(4000);  
   sendcommand(0x23);
   sendcommand(0x00);
   delay(2000);  
  /*
   while(1)
   {
   //sendcommand(0xa6);  Set Normal Display
   sendcommand(0x29);  //Vertical and Horizontal Scroll Setup
   sendcommand(0x00);  //dummy byte
   sendcommand(0x00);  //define page0 as startpage address
   sendcommand(0x00);  //set time interval between each scroll ste as 6 frames
   sendcommand(0x07);  //define page7 as endpage address
   sendcommand(0x01);  //set vertical scrolling offset as 1 row
   sendcommand(0x2f);  //active scrolling
   delay(3000);
   
   };
   */
}

//==========================================================//
void sendcommand(unsigned char com)
{
  i2c_OLED_send_cmd(com);  
  /*
  Wire.beginTransmission(OLED_address);     //begin transmitting
   Wire.write(0x80);                          //command mode
   Wire.write(com);
   Wire.endTransmission();                    // stop transmitting
   */
}

//==========================================================//
void clear_display(void)
{
  unsigned char i,k;
  /*for(k=0;k<8;k++)
  {	
    setXY(k,0);    
    {
      for(i=0;i<128;i++)     //clear all COL
      {
        SendChar(0);         //clear all COL
        //delay(10);
      }
    }
  }
  */
  for(int col = 0; col < 128; col++)     // show 128* 64 picture
  {
    for( int row = 0; row < 8; row++ )
    {
      SendChar(0);
    }
  }
}

//==========================================================//
void SendChar(unsigned char data)
{
  i2c_OLED_send_byte(data);
  /*
  Wire.beginTransmission(OLED_address); // begin transmitting
   Wire.write(0x40);//data mode
   Wire.write(data);
   Wire.endTransmission();    // stop transmitting
   */
}

//==========================================================//
void setXY(unsigned char row,unsigned char col)
{
  sendcommand(0xb0+row);                //set page address
  sendcommand(0x00+(8*col&0x0f));       //set low col address
  sendcommand(0x10+((8*col>>4)&0x0f));  //set high col address
}


//==========================================================//
/*void sendStr(unsigned char *string)
{
  unsigned char i=0;
  //setXY(0,0);    
  while(*string)
  {
    for(i=0;i<CHAR_WIDTH;i++)
    {
      SendChar(myFont[*string-0x20][i]);

      // SendChar(*string);
      //delay(10);
    }
    *string++;
  }
}*/

//==========================================================//
void init_OLED(void)
{
  i2c_OLED_init();

}

void  i2c_OLED_init(void){
  delay(50);
  i2c_OLED_send_cmd(0xae);    //display off
  i2c_OLED_send_cmd(0x2e);    //deactivate scrolling
  i2c_OLED_send_cmd(0xa4);          //SET All pixels OFF
  //  i2c_OLED_send_cmd(0xa5);            //SET ALL pixels ON
  delay(50);
  i2c_OLED_send_cmd(0x20);            //Set Memory Addressing Mode
  i2c_OLED_send_cmd(0x00);            //Set Memory Addressing Mode to Page addressing mode(RESET)
  //  i2c_OLED_send_cmd(0xa0);      //colum address 0 mapped to SEG0 (POR)*** wires at bottom
  i2c_OLED_send_cmd(0xa1);    //colum address 127 mapped to SEG0 (POR) ** wires at top of board
  //  i2c_OLED_send_cmd(0xC0);            // Scan from Right to Left (POR)         *** wires at bottom
  i2c_OLED_send_cmd(0xC8);          // Scan from Left to Right               ** wires at top
  i2c_OLED_send_cmd(0xa6);            // Set WHITE chars on BLACK backround

  //  i2c_OLED_send_cmd(0xa7);            // Set BLACK chars on WHITE backround
  i2c_OLED_send_cmd(0x81);            // 81 Setup CONTRAST CONTROL, following byte is the contrast Value
  i2c_OLED_send_cmd(0x01);            // af contrast value between 1 ( == dull) to 256 ( == bright)
  delay(20);

  i2c_OLED_send_cmd(0xaf);          //display on
  delay(20);
}


// ************************************************************************************************************
// I2C general functions
// ************************************************************************************************************

static uint32_t neutralizeTime = 0;
static int16_t  i2c_errors_count = 0;

#define I2C_SPEED 400000L     //100kHz normal mode, this value must be used for a genuine WMP

#define I2C_PULLUPS_ENABLE         PORTC |= 1<<4; PORTC |= 1<<5;   // PIN A4&A5 (SDA&SCL)
#define I2C_PULLUPS_DISABLE        PORTC &= ~(1<<4); PORTC &= ~(1<<5);

void i2c_init(void) {
#if defined(INTERNAL_I2C_PULLUPS)
  I2C_PULLUPS_ENABLE
#else
    I2C_PULLUPS_DISABLE
#endif
    TWSR = 0;                                    // no prescaler => prescaler = 1
  TWBR = ((F_CPU / I2C_SPEED) - 16) / 2;   // change the I2C clock rate
  TWCR = 1<<TWEN;                              // enable twi module, no interrupt
}

void i2c_rep_start(uint8_t address) {
  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN) ; // send REPEAT START condition
  waitTransmissionI2C();                       // wait until transmission completed
  TWDR = address;                              // send device address
  TWCR = (1<<TWINT) | (1<<TWEN);
  waitTransmissionI2C();                       // wail until transmission completed
}

void i2c_stop(void) {
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
  //  while(TWCR & (1<<TWSTO));                // <- can produce a blocking state with some WMP clones
}

void i2c_write(uint8_t data ) {	
  TWDR = data;                                 // send data to the previously addressed device
  TWCR = (1<<TWINT) | (1<<TWEN);
  waitTransmissionI2C();
}
/*
uint8_t i2c_read(uint8_t ack) {
 TWCR = (1<<TWINT) | (1<<TWEN) | (ack? (1<<TWEA) : 0);
 waitTransmissionI2C();
 uint8_t r = TWDR;
 if (!ack) i2c_stop();
 return r;
 }*/
/*
uint8_t i2c_readAck() {
 return i2c_read(1);
 }*/
/*
uint8_t i2c_readNak(void) {
 return i2c_read(0);
 }*/

void waitTransmissionI2C() {
  uint16_t count = 255;
  while (!(TWCR & (1<<TWINT))) {
    count--;
    if (count==0) {              //we are in a blocking state => we don't insist
      TWCR = 0;                  //and we force a reset on TWINT register
      neutralizeTime = micros(); //we take a timestamp here to neutralize the value during a short delay
      i2c_errors_count++;
      break;
    }
  }
}
/*
size_t i2c_read_to_buf(uint8_t add, void *buf, size_t size) {
 i2c_rep_start((add<<1) | 1);	// I2C read direction
 size_t bytes_read = 0;
 uint8_t *b = (uint8_t*)buf;
 while (size--) {
 // acknowledge all but the final byte 
 *b++ = i2c_read(size > 0);
 // TODO catch I2C errors here and abort 
 bytes_read++;
 }
 return bytes_read;
 }*/
/*
size_t i2c_read_reg_to_buf(uint8_t add, uint8_t reg, void *buf, size_t size) {
 i2c_rep_start(add<<1); // I2C write direction
 i2c_write(reg);        // register selection
 return i2c_read_to_buf(add, buf, size);
 }
 */
/* transform a series of bytes from big endian to little
 endian and vice versa. */
/*void swap_endianness(void *buf, size_t size) {
 // we swap in-place, so we only have to
 // place _one_ element on a temporary tray
 //
 uint8_t tray;
 uint8_t *from;
 uint8_t *to;
 // keep swapping until the pointers have assed each other
 for (from = (uint8_t*)buf, to = &from[size-1]; from < to; from++, to--) {
 tray = *from;
 *from = *to;
 *to = tray;
 }
 }*/

void i2c_writeReg(uint8_t add, uint8_t reg, uint8_t val) {
  i2c_rep_start(add<<1); // I2C write direction
  i2c_write(reg);        // register selection
  i2c_write(val);        // value to write in register
  i2c_stop();
}


void i2c_OLED_send_cmd(uint8_t command) {
  TWBR = 12;//TWBR = ((F_CPU / 400000L) - 16) / 2; // change the I2C clock rate
  i2c_writeReg(OLED_address, 0x80, (uint8_t)command);
}

void i2c_OLED_send_byte(uint8_t val) {
  TWBR = 12;//TWBR = ((F_CPU / 400000L) - 16) / 2; // change the I2C clock rate
  i2c_writeReg(OLED_address, 0x40, (uint8_t)val);
}




